#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Risk Field Visualization Analyzer (International Version)
English version of the risk field visualization analysis tool

This module provides interactive tools for analyzing and interpreting
risk field visualizations generated by the risk field model.

Author: Risk Field Model Team
Date: 2024
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
from typing import Dict, List, Tuple, Optional
import warnings

class RiskFieldAnalyzer:
    """
    Risk Field Analyzer
    
    Provides comprehensive analysis and interpretation of risk field visualizations
    """
    
    def __init__(self):
        """Initialize the analyzer"""
        self.risk_levels = {
            'safe': (0, 1000),
            'low': (1000, 5000),
            'medium': (5000, 20000),
            'high': (20000, 100000),
            'extreme': (100000, float('inf'))
        }
        
        self.risk_colors = {
            'safe': '#000080',      # Deep blue
            'low': '#0066CC',       # Blue
            'medium': '#6600CC',    # Purple
            'high': '#CC6600',      # Orange
            'extreme': '#CC0000'    # Red
        }
        
        # Scenario type patterns
        self.scenario_patterns = {
            'highway_straight': 'Highway Straight Driving',
            'overtaking': 'Overtaking Scenario',
            'lane_change': 'Lane Change Scenario', 
            'merging': 'Merging Scenario',
            'emergency_brake': 'Emergency Braking',
            'multi_vehicle': 'Multi-Vehicle Interaction'
        }
    
    def analyze_risk_field(self, F_total: np.ndarray, x_range: Tuple[float, float], 
                          y_range: Tuple[float, float]) -> Dict:
        """
        Comprehensive risk field analysis
        
        Args:
            F_total: Risk field matrix
            x_range: X-axis range (min, max)
            y_range: Y-axis range (min, max)
            
        Returns:
            Dict: Analysis results
        """
        print("üîç Starting Risk Field Analysis...")
        print("=" * 50)
        
        # Basic statistics
        basic_stats = self._calculate_basic_stats(F_total)
        
        # Risk distribution analysis
        risk_distribution = self._analyze_risk_distribution(F_total)
        
        # Peak detection
        peaks_info = self._detect_peaks(F_total, x_range, y_range)
        
        # Scenario identification
        scenario_type = self._identify_scenario(F_total, peaks_info)
        
        # Lane analysis
        lane_analysis = self._analyze_lanes(F_total, y_range)
        
        # Safety assessment
        safety_assessment = self._assess_safety(basic_stats, risk_distribution)
        
        # Decision advice
        decision_advice = self._generate_advice(basic_stats, scenario_type, safety_assessment)
        
        # Print analysis results
        self._print_analysis_results(basic_stats, risk_distribution, peaks_info, 
                                   scenario_type, lane_analysis, safety_assessment, 
                                   decision_advice)
        
        return {
            'basic_stats': basic_stats,
            'risk_distribution': risk_distribution,
            'peaks_info': peaks_info,
            'scenario_type': scenario_type,
            'lane_analysis': lane_analysis,
            'safety_assessment': safety_assessment,
            'decision_advice': decision_advice
        }
    
    def _calculate_basic_stats(self, F_total: np.ndarray) -> Dict:
        """Calculate basic statistical information"""
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            
            return {
                'max_risk': float(np.max(F_total)),
                'min_risk': float(np.min(F_total)),
                'mean_risk': float(np.mean(F_total)),
                'std_risk': float(np.std(F_total)),
                'total_points': F_total.size,
                'shape': F_total.shape
            }
    
    def _analyze_risk_distribution(self, F_total: np.ndarray) -> Dict:
        """Analyze risk distribution"""
        distribution = {}
        total_points = F_total.size
        
        for level, (min_val, max_val) in self.risk_levels.items():
            if max_val == float('inf'):
                count = np.sum(F_total >= min_val)
            else:
                count = np.sum((F_total >= min_val) & (F_total < max_val))
            
            distribution[level] = {
                'count': int(count),
                'percentage': float(count / total_points * 100)
            }
        
        return distribution
    
    def _detect_peaks(self, F_total: np.ndarray, x_range: Tuple[float, float], 
                     y_range: Tuple[float, float]) -> List[Dict]:
        """Detect risk peaks"""
        from scipy.signal import find_peaks
        
        peaks_info = []
        
        # Threshold setting (20% of max value as peak detection threshold)
        threshold = np.max(F_total) * 0.2
        
        # Find peaks in each row
        dy = (y_range[1] - y_range[0]) / F_total.shape[0]
        dx = (x_range[1] - x_range[0]) / F_total.shape[1]
        
        for i, row in enumerate(F_total):
            if np.max(row) > threshold:
                peaks, properties = find_peaks(row, height=threshold, distance=5)
                
                for j, peak_idx in enumerate(peaks):
                    peak_info = {
                        'x_pos': x_range[0] + peak_idx * dx,
                        'y_pos': y_range[0] + i * dy,
                        'risk_value': float(F_total[i, peak_idx]),
                        'x_index': peak_idx,
                        'y_index': i
                    }
                    peaks_info.append(peak_info)
        
        # Sort by risk value
        peaks_info.sort(key=lambda x: x['risk_value'], reverse=True)
        
        return peaks_info[:10]  # Return top 10 peaks
    
    def _identify_scenario(self, F_total: np.ndarray, peaks_info: List[Dict]) -> Dict:
        """Identify driving scenario type"""
        if len(peaks_info) == 0:
            return {'type': 'safe_driving', 'confidence': 1.0, 'description': 'Safe Driving'}
        
        max_risk = np.max(F_total)
        num_peaks = len(peaks_info)
        
        # Scenario identification logic
        if max_risk > 50000:
            scenario_type = 'emergency_brake'
            description = 'Emergency Braking Scenario'
            confidence = 0.9
        elif num_peaks >= 4:
            scenario_type = 'multi_vehicle' 
            description = 'Multi-Vehicle Interaction'
            confidence = 0.8
        elif num_peaks >= 2:
            # Check for parallel vehicles (overtaking/lane change)
            y_positions = [peak['y_pos'] for peak in peaks_info[:3]]
            if len(set(np.round(np.array(y_positions), 1))) >= 2:
                scenario_type = 'overtaking'
                description = 'Overtaking/Lane Change Scenario'
                confidence = 0.7
            else:
                scenario_type = 'highway_straight'
                description = 'Highway Straight Driving'
                confidence = 0.8
        else:
            scenario_type = 'highway_straight'
            description = 'Single Vehicle or Simple Scenario'
            confidence = 0.6
        
        return {
            'type': scenario_type,
            'confidence': confidence,
            'description': description,
            'num_vehicles_detected': num_peaks
        }
    
    def _analyze_lanes(self, F_total: np.ndarray, y_range: Tuple[float, float]) -> Dict:
        """Analyze lane risk distribution"""
        height = F_total.shape[0]
        
        # Assume standard highway: 0-4m (right), 4-8m (middle), 8-12m (left)
        if y_range[1] <= 8:  # Two lanes
            right_lane_idx = slice(0, height//2)
            left_lane_idx = slice(height//2, height)
            lanes = ['right', 'left']
        else:  # Three or more lanes
            right_lane_idx = slice(0, height//3)
            middle_lane_idx = slice(height//3, 2*height//3)
            left_lane_idx = slice(2*height//3, height)
            lanes = ['right', 'middle', 'left']
        
        lane_stats = {}
        
        if y_range[1] <= 8:
            lane_stats['right'] = {
                'mean_risk': float(np.mean(F_total[right_lane_idx, :])),
                'max_risk': float(np.max(F_total[right_lane_idx, :]))
            }
            lane_stats['left'] = {
                'mean_risk': float(np.mean(F_total[left_lane_idx, :])),
                'max_risk': float(np.max(F_total[left_lane_idx, :]))
            }
        else:
            lane_stats['right'] = {
                'mean_risk': float(np.mean(F_total[right_lane_idx, :])),
                'max_risk': float(np.max(F_total[right_lane_idx, :]))
            }
            lane_stats['middle'] = {
                'mean_risk': float(np.mean(F_total[middle_lane_idx, :])),
                'max_risk': float(np.max(F_total[middle_lane_idx, :]))
            }
            lane_stats['left'] = {
                'mean_risk': float(np.mean(F_total[left_lane_idx, :])),
                'max_risk': float(np.max(F_total[left_lane_idx, :]))
            }
        
        # Recommend safest lane
        safest_lane = min(lane_stats.keys(), key=lambda x: lane_stats[x]['mean_risk'])
        
        return {
            'lane_stats': lane_stats,
            'safest_lane': safest_lane,
            'lanes_detected': lanes
        }
    
    def _assess_safety(self, basic_stats: Dict, risk_distribution: Dict) -> Dict:
        """Assess safety level"""
        max_risk = basic_stats['max_risk']
        mean_risk = basic_stats['mean_risk']
        
        # Safety level assessment
        if max_risk > 100000:
            safety_level = 'critical'
            safety_score = 0
        elif max_risk > 20000:
            safety_level = 'dangerous'
            safety_score = 20
        elif max_risk > 5000:
            safety_level = 'caution'
            safety_score = 60
        elif mean_risk > 1000:
            safety_level = 'low_risk'
            safety_score = 80
        else:
            safety_level = 'safe'
            safety_score = 95
        
        # Adjust based on distribution
        if risk_distribution['high']['percentage'] > 10:
            safety_score = max(0, safety_score - 30)
        elif risk_distribution['medium']['percentage'] > 20:
            safety_score = max(0, safety_score - 15)
        
        return {
            'safety_level': safety_level,
            'safety_score': safety_score,
            'max_risk_level': self._get_risk_level(max_risk),
            'mean_risk_level': self._get_risk_level(mean_risk)
        }
    
    def _get_risk_level(self, risk_value: float) -> str:
        """Get risk level category"""
        for level, (min_val, max_val) in self.risk_levels.items():
            if min_val <= risk_value < max_val:
                return level
        return 'extreme'
    
    def _generate_advice(self, basic_stats: Dict, scenario_type: Dict, 
                        safety_assessment: Dict) -> List[str]:
        """Generate driving advice"""
        advice = []
        
        safety_level = safety_assessment['safety_level']
        max_risk = basic_stats['max_risk']
        scenario = scenario_type['type']
        
        # Safety level based advice
        if safety_level == 'critical':
            advice.extend([
                "üö® Take immediate emergency action!",
                "‚ö° Emergency braking or evasive maneuver",
                "üìû Consider activating emergency call system"
            ])
        elif safety_level == 'dangerous':
            advice.extend([
                "‚ö†Ô∏è High risk state! Reduce speed immediately",
                "üîÑ Prepare to change to safe lane",
                "üëÅÔ∏è Heighten alertness, prepare for emergency response"
            ])
        elif safety_level == 'caution':
            advice.extend([
                "üî∂ Maintain cautious driving",
                "üìâ Reduce speed appropriately",
                "üìç Increase following distance"
            ])
        
        # Scenario based advice
        if scenario == 'overtaking':
            advice.append("üöó Overtaking scenario: Confirm safe distance before completing maneuver")
        elif scenario == 'multi_vehicle':
            advice.append("üöô Multi-vehicle environment: Maintain safe distances, avoid sudden movements")
        elif scenario == 'emergency_brake':
            advice.append("üõë Emergency braking: Check rear traffic, activate hazard lights")
        
        # General advice
        if max_risk > 10000:
            advice.append("üéØ Recommend activating Advanced Driver Assistance Systems (ADAS)")
        
        return advice if advice else ["‚úÖ Current environment is relatively safe, maintain normal driving"]
    
    def _print_analysis_results(self, basic_stats: Dict, risk_distribution: Dict,
                              peaks_info: List[Dict], scenario_type: Dict,
                              lane_analysis: Dict, safety_assessment: Dict,
                              decision_advice: List[str]):
        """Print analysis results"""
        print("\nüìä Basic Statistics")
        print("-" * 30)
        print(f"Maximum Risk: {basic_stats['max_risk']:.2f} N")
        print(f"Mean Risk: {basic_stats['mean_risk']:.2f} N")
        print(f"Risk Std Dev: {basic_stats['std_risk']:.2f} N")
        print(f"Analysis Grid: {basic_stats['shape'][0]} √ó {basic_stats['shape'][1]}")
        
        print("\nüéØ Risk Distribution")
        print("-" * 30)
        level_names = {
            'safe': 'Safe',
            'low': 'Low Risk', 
            'medium': 'Medium Risk',
            'high': 'High Risk',
            'extreme': 'Extreme Risk'
        }
        for level, data in risk_distribution.items():
            print(f"{level_names[level]}: {data['percentage']:.1f}% ({data['count']} points)")
        
        print(f"\nüèîÔ∏è Detected {len(peaks_info)} Risk Peaks")
        print("-" * 30)
        for i, peak in enumerate(peaks_info[:5]):  # Show top 5
            print(f"Peak {i+1}: X={peak['x_pos']:.1f}m, Y={peak['y_pos']:.1f}m, "
                  f"Risk={peak['risk_value']:.0f}N")
        
        print(f"\nüé¨ Scenario Identification")
        print("-" * 30)
        print(f"Scenario Type: {scenario_type['description']}")
        print(f"Confidence: {scenario_type['confidence']:.1%}")
        print(f"Detected Vehicles: {scenario_type['num_vehicles_detected']}")
        
        print(f"\nüõ£Ô∏è Lane Analysis")
        print("-" * 30)
        lane_names = {'right': 'Right Lane', 'middle': 'Middle Lane', 'left': 'Left Lane'}
        for lane_name, stats in lane_analysis['lane_stats'].items():
            display_name = lane_names[lane_name]
            print(f"{display_name}: Mean Risk {stats['mean_risk']:.0f}N, "
                  f"Max Risk {stats['max_risk']:.0f}N")
        
        safest_display = lane_names[lane_analysis['safest_lane']]
        print(f"Recommended Lane: {safest_display}")
        
        print(f"\nüõ°Ô∏è Safety Assessment")
        print("-" * 30)
        safety_names = {
            'safe': 'Safe',
            'low_risk': 'Low Risk',
            'caution': 'Caution Required',
            'dangerous': 'Dangerous',
            'critical': 'Critical'
        }
        print(f"Safety Level: {safety_names[safety_assessment['safety_level']]}")
        print(f"Safety Score: {safety_assessment['safety_score']}/100")
        
        print(f"\nüí° Driving Recommendations")
        print("-" * 30)
        for advice in decision_advice:
            print(f"  {advice}")
        
        print("\n" + "=" * 50)
        print("‚úÖ Analysis Complete!")

    def create_enhanced_visualization(self, F_total: np.ndarray, x_range: Tuple[float, float],
                                    y_range: Tuple[float, float], peaks_info: List[Dict]):
        """Create enhanced visualization with English labels"""
        fig = plt.figure(figsize=(15, 10))
        
        # 3D plot
        ax1 = fig.add_subplot(221, projection='3d')
        
        X = np.linspace(x_range[0], x_range[1], F_total.shape[1])
        Y = np.linspace(y_range[0], y_range[1], F_total.shape[0])
        X, Y = np.meshgrid(X, Y)
        
        surf = ax1.plot_surface(X, Y, F_total, cmap='viridis', alpha=0.8)
        
        # Mark peaks
        for i, peak in enumerate(peaks_info[:5]):
            ax1.scatter([peak['x_pos']], [peak['y_pos']], [peak['risk_value']], 
                       c='red', s=100, alpha=0.8)
            ax1.text(peak['x_pos'], peak['y_pos'], peak['risk_value'] + 1000,
                    f'P{i+1}', fontsize=8)
        
        ax1.set_title('3D Risk Field Visualization')
        ax1.set_xlabel('X [m]')
        ax1.set_ylabel('Y [m]') 
        ax1.set_zlabel('Risk [N]')
        
        # Top view
        ax2 = fig.add_subplot(222)
        im = ax2.imshow(F_total, extent=[x_range[0], x_range[1], y_range[0], y_range[1]],
                       origin='lower', cmap='viridis', aspect='auto')
        
        # Mark peaks
        for i, peak in enumerate(peaks_info[:5]):
            ax2.scatter(peak['x_pos'], peak['y_pos'], c='red', s=100, 
                       marker='x', linewidths=2)
            ax2.text(peak['x_pos'] + 2, peak['y_pos'] + 0.2, f'P{i+1}', 
                    color='red', fontweight='bold')
        
        ax2.set_title('Top View - Risk Distribution')
        ax2.set_xlabel('X [m]')
        ax2.set_ylabel('Y [m]')
        plt.colorbar(im, ax=ax2, label='Risk [N]')
        
        # Lateral risk distribution
        ax3 = fig.add_subplot(223)
        y_profile = np.mean(F_total, axis=1)
        ax3.plot(Y[:, 0], y_profile, 'b-', linewidth=2)
        ax3.fill_between(Y[:, 0], y_profile, alpha=0.3)
        ax3.set_title('Lateral Risk Distribution (Lane Direction)')
        ax3.set_xlabel('Y [m] (Lane Position)')
        ax3.set_ylabel('Mean Risk [N]')
        ax3.grid(True, alpha=0.3)
        
        # Longitudinal risk distribution
        ax4 = fig.add_subplot(224)
        x_profile = np.mean(F_total, axis=0)
        ax4.plot(X[0, :], x_profile, 'g-', linewidth=2)
        ax4.fill_between(X[0, :], x_profile, alpha=0.3)
        ax4.set_title('Longitudinal Risk Distribution (Driving Direction)')
        ax4.set_xlabel('X [m] (Driving Direction)')
        ax4.set_ylabel('Mean Risk [N]')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

def main():
    """Main function - demonstrate analyzer usage"""
    print("üöó Risk Field Visualization Analyzer")
    print("=" * 50)
    
    # Create analyzer
    analyzer = RiskFieldAnalyzer()
    
    # Load example data
    try:
        from risk_field_model import RiskFieldModel
        
        # Create example scenario
        model = RiskFieldModel(performance_mode='fast')
        
        # Example vehicle data (format: [id, x, y, speed, ...])
        vehicles = [
            [1, 20, 2.5, 25],    # id, x, y, speed
            [2, 45, 6.5, 30], 
            [3, 70, 2.0, 28],
        ]
        
        # Calculate risk field
        F_total, _, _, _ = model.calculate_scene_risk_field(vehicles)
        
        # Perform analysis
        analysis_results = analyzer.analyze_risk_field(F_total, (0, 100), (0, 8))
        
        # Create enhanced visualization
        fig = analyzer.create_enhanced_visualization(
            F_total, (0, 100), (0, 8), analysis_results['peaks_info']
        )
        plt.show()
        
        print(f"\nüìà Analysis report generated!")
        print(f"üéØ Safety Score: {analysis_results['safety_assessment']['safety_score']}/100")
        
    except ImportError as e:
        print(f"‚ùå Cannot import risk field model: {e}")
        print("Please ensure risk_field_model.py is in the current directory")

if __name__ == "__main__":
    main()

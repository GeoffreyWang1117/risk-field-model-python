#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Risk Field Visualization Analyzer
风险场可视化分析工具

This module provides interactive tools for analyzing and interpreting
risk field visualizations generated by the risk field model.

Author: Risk Field Model Team
Date: 2024
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
from typing import Dict, List, Tuple, Optional
import warnings

class RiskFieldAnalyzer:
    """
    风险场分析器
    
    提供风险场可视化的自动分析和解读功能
    """
    
    def __init__(self):
        """初始化分析器"""
        self.risk_levels = {
            'safe': (0, 1000),
            'low': (1000, 5000),
            'medium': (5000, 20000),
            'high': (20000, 100000),
            'extreme': (100000, float('inf'))
        }
        
        self.risk_colors = {
            'safe': '#000080',      # 深蓝
            'low': '#0066CC',       # 蓝色
            'medium': '#6600CC',    # 紫色
            'high': '#CC6600',      # 橙色
            'extreme': '#CC0000'    # 红色
        }
        
        # 场景类型模式
        self.scenario_patterns = {
            'highway_straight': '高速直行',
            'overtaking': '超车场景',
            'lane_change': '变道场景', 
            'merging': '汇入场景',
            'emergency_brake': '紧急制动',
            'multi_vehicle': '多车交互'
        }
    
    def analyze_risk_field(self, F_total: np.ndarray, x_range: Tuple[float, float], 
                          y_range: Tuple[float, float]) -> Dict:
        """
        全面分析风险场
        
        Args:
            F_total: 风险场矩阵
            x_range: X轴范围 (min, max)
            y_range: Y轴范围 (min, max)
            
        Returns:
            Dict: 分析结果
        """
        print("🔍 开始风险场分析...")
        print("=" * 50)
        
        # 基础统计
        basic_stats = self._calculate_basic_stats(F_total)
        
        # 风险分布分析
        risk_distribution = self._analyze_risk_distribution(F_total)
        
        # 峰值检测
        peaks_info = self._detect_peaks(F_total, x_range, y_range)
        
        # 场景识别
        scenario_type = self._identify_scenario(F_total, peaks_info)
        
        # 车道分析
        lane_analysis = self._analyze_lanes(F_total, y_range)
        
        # 安全评估
        safety_assessment = self._assess_safety(basic_stats, risk_distribution)
        
        # 决策建议
        decision_advice = self._generate_advice(basic_stats, scenario_type, safety_assessment)
        
        # 打印分析结果
        self._print_analysis_results(basic_stats, risk_distribution, peaks_info, 
                                   scenario_type, lane_analysis, safety_assessment, 
                                   decision_advice)
        
        return {
            'basic_stats': basic_stats,
            'risk_distribution': risk_distribution,
            'peaks_info': peaks_info,
            'scenario_type': scenario_type,
            'lane_analysis': lane_analysis,
            'safety_assessment': safety_assessment,
            'decision_advice': decision_advice
        }
    
    def _calculate_basic_stats(self, F_total: np.ndarray) -> Dict:
        """计算基础统计信息"""
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            
            return {
                'max_risk': float(np.max(F_total)),
                'min_risk': float(np.min(F_total)),
                'mean_risk': float(np.mean(F_total)),
                'std_risk': float(np.std(F_total)),
                'total_points': F_total.size,
                'shape': F_total.shape
            }
    
    def _analyze_risk_distribution(self, F_total: np.ndarray) -> Dict:
        """分析风险分布"""
        distribution = {}
        total_points = F_total.size
        
        for level, (min_val, max_val) in self.risk_levels.items():
            if max_val == float('inf'):
                count = np.sum(F_total >= min_val)
            else:
                count = np.sum((F_total >= min_val) & (F_total < max_val))
            
            distribution[level] = {
                'count': int(count),
                'percentage': float(count / total_points * 100)
            }
        
        return distribution
    
    def _detect_peaks(self, F_total: np.ndarray, x_range: Tuple[float, float], 
                     y_range: Tuple[float, float]) -> List[Dict]:
        """检测风险峰值"""
        from scipy.signal import find_peaks
        
        peaks_info = []
        
        # 阈值设定（取最大值的20%作为峰值检测阈值）
        threshold = np.max(F_total) * 0.2
        
        # 在每一行中寻找峰值
        dy = (y_range[1] - y_range[0]) / F_total.shape[0]
        dx = (x_range[1] - x_range[0]) / F_total.shape[1]
        
        for i, row in enumerate(F_total):
            if np.max(row) > threshold:
                peaks, properties = find_peaks(row, height=threshold, distance=5)
                
                for j, peak_idx in enumerate(peaks):
                    peak_info = {
                        'x_pos': x_range[0] + peak_idx * dx,
                        'y_pos': y_range[0] + i * dy,
                        'risk_value': float(F_total[i, peak_idx]),
                        'x_index': peak_idx,
                        'y_index': i
                    }
                    peaks_info.append(peak_info)
        
        # 按风险值排序
        peaks_info.sort(key=lambda x: x['risk_value'], reverse=True)
        
        return peaks_info[:10]  # 返回前10个最高峰值
    
    def _identify_scenario(self, F_total: np.ndarray, peaks_info: List[Dict]) -> Dict:
        """识别驾驶场景类型"""
        if len(peaks_info) == 0:
            return {'type': 'safe_driving', 'confidence': 1.0, 'description': '安全驾驶'}
        
        max_risk = np.max(F_total)
        num_peaks = len(peaks_info)
        
        # 场景判断逻辑
        if max_risk > 50000:
            scenario_type = 'emergency_brake'
            description = '紧急制动场景'
            confidence = 0.9
        elif num_peaks >= 4:
            scenario_type = 'multi_vehicle' 
            description = '多车交互场景'
            confidence = 0.8
        elif num_peaks >= 2:
            # 检查是否为并排（超车/变道）
            y_positions = [peak['y_pos'] for peak in peaks_info[:3]]
            if len(set(np.round(np.array(y_positions), 1))) >= 2:
                scenario_type = 'overtaking'
                description = '超车/变道场景'
                confidence = 0.7
            else:
                scenario_type = 'highway_straight'
                description = '高速直行场景'
                confidence = 0.8
        else:
            scenario_type = 'highway_straight'
            description = '单车或简单场景'
            confidence = 0.6
        
        return {
            'type': scenario_type,
            'confidence': confidence,
            'description': description,
            'num_vehicles_detected': num_peaks
        }
    
    def _analyze_lanes(self, F_total: np.ndarray, y_range: Tuple[float, float]) -> Dict:
        """分析车道风险分布"""
        height = F_total.shape[0]
        
        # 假设标准3车道高速公路：0-4m (右), 4-8m (中), 8-12m (左)
        if y_range[1] <= 8:  # 双车道
            right_lane_idx = slice(0, height//2)
            left_lane_idx = slice(height//2, height)
            lanes = ['right', 'left']
        else:  # 三车道或更多
            right_lane_idx = slice(0, height//3)
            middle_lane_idx = slice(height//3, 2*height//3)
            left_lane_idx = slice(2*height//3, height)
            lanes = ['right', 'middle', 'left']
        
        lane_stats = {}
        
        if y_range[1] <= 8:
            lane_stats['right'] = {
                'mean_risk': float(np.mean(F_total[right_lane_idx, :])),
                'max_risk': float(np.max(F_total[right_lane_idx, :]))
            }
            lane_stats['left'] = {
                'mean_risk': float(np.mean(F_total[left_lane_idx, :])),
                'max_risk': float(np.max(F_total[left_lane_idx, :]))
            }
        else:
            lane_stats['right'] = {
                'mean_risk': float(np.mean(F_total[right_lane_idx, :])),
                'max_risk': float(np.max(F_total[right_lane_idx, :]))
            }
            lane_stats['middle'] = {
                'mean_risk': float(np.mean(F_total[middle_lane_idx, :])),
                'max_risk': float(np.max(F_total[middle_lane_idx, :]))
            }
            lane_stats['left'] = {
                'mean_risk': float(np.mean(F_total[left_lane_idx, :])),
                'max_risk': float(np.max(F_total[left_lane_idx, :]))
            }
        
        # 推荐车道
        safest_lane = min(lane_stats.keys(), key=lambda x: lane_stats[x]['mean_risk'])
        
        return {
            'lane_stats': lane_stats,
            'safest_lane': safest_lane,
            'lanes_detected': lanes
        }
    
    def _assess_safety(self, basic_stats: Dict, risk_distribution: Dict) -> Dict:
        """安全评估"""
        max_risk = basic_stats['max_risk']
        mean_risk = basic_stats['mean_risk']
        
        # 安全等级评估
        if max_risk > 100000:
            safety_level = 'critical'
            safety_score = 0
        elif max_risk > 20000:
            safety_level = 'dangerous'
            safety_score = 20
        elif max_risk > 5000:
            safety_level = 'caution'
            safety_score = 60
        elif mean_risk > 1000:
            safety_level = 'low_risk'
            safety_score = 80
        else:
            safety_level = 'safe'
            safety_score = 95
        
        # 基于分布的调整
        if risk_distribution['high']['percentage'] > 10:
            safety_score = max(0, safety_score - 30)
        elif risk_distribution['medium']['percentage'] > 20:
            safety_score = max(0, safety_score - 15)
        
        return {
            'safety_level': safety_level,
            'safety_score': safety_score,
            'max_risk_level': self._get_risk_level(max_risk),
            'mean_risk_level': self._get_risk_level(mean_risk)
        }
    
    def _get_risk_level(self, risk_value: float) -> str:
        """获取风险等级"""
        for level, (min_val, max_val) in self.risk_levels.items():
            if min_val <= risk_value < max_val:
                return level
        return 'extreme'
    
    def _generate_advice(self, basic_stats: Dict, scenario_type: Dict, 
                        safety_assessment: Dict) -> List[str]:
        """生成驾驶建议"""
        advice = []
        
        safety_level = safety_assessment['safety_level']
        max_risk = basic_stats['max_risk']
        scenario = scenario_type['type']
        
        # 基于安全等级的建议
        if safety_level == 'critical':
            advice.extend([
                "🚨 立即采取紧急措施！",
                "⚡ 紧急制动或紧急避让",
                "📞 考虑启动紧急呼叫系统"
            ])
        elif safety_level == 'dangerous':
            advice.extend([
                "⚠️ 高风险状态！立即减速",
                "🔄 准备变道到安全车道",
                "👁️ 提高警惕，准备应急反应"
            ])
        elif safety_level == 'caution':
            advice.extend([
                "🔶 保持谨慎驾驶",
                "📉 适当降低车速",
                "📍 增大与前车距离"
            ])
        
        # 基于场景的建议
        if scenario == 'overtaking':
            advice.append("🚗 超车场景：确认安全距离后完成超车")
        elif scenario == 'multi_vehicle':
            advice.append("🚙 多车环境：保持安全车距，避免急动作")
        elif scenario == 'emergency_brake':
            advice.append("🛑 紧急制动：检查后方车辆，开启危险警告灯")
        
        # 通用建议
        if max_risk > 10000:
            advice.append("🎯 建议激活高级驾驶辅助系统(ADAS)")
        
        return advice if advice else ["✅ 当前环境相对安全，保持正常驾驶"]
    
    def _print_analysis_results(self, basic_stats: Dict, risk_distribution: Dict,
                              peaks_info: List[Dict], scenario_type: Dict,
                              lane_analysis: Dict, safety_assessment: Dict,
                              decision_advice: List[str]):
        """打印分析结果"""
        print("\n📊 基础统计信息")
        print("-" * 30)
        print(f"最大风险值: {basic_stats['max_risk']:.2f} N")
        print(f"平均风险值: {basic_stats['mean_risk']:.2f} N")
        print(f"风险标准差: {basic_stats['std_risk']:.2f} N")
        print(f"分析网格: {basic_stats['shape'][0]} × {basic_stats['shape'][1]}")
        
        print("\n🎯 风险分布")
        print("-" * 30)
        for level, data in risk_distribution.items():
            level_name = {
                'safe': '安全',
                'low': '低风险', 
                'medium': '中等风险',
                'high': '高风险',
                'extreme': '极高风险'
            }[level]
            print(f"{level_name}: {data['percentage']:.1f}% ({data['count']} 点)")
        
        print(f"\n🏔️ 检测到 {len(peaks_info)} 个风险峰值")
        print("-" * 30)
        for i, peak in enumerate(peaks_info[:5]):  # 显示前5个
            print(f"峰值 {i+1}: X={peak['x_pos']:.1f}m, Y={peak['y_pos']:.1f}m, "
                  f"风险={peak['risk_value']:.0f}N")
        
        print(f"\n🎬 场景识别")
        print("-" * 30)
        print(f"场景类型: {scenario_type['description']}")
        print(f"置信度: {scenario_type['confidence']:.1%}")
        print(f"检测车辆数: {scenario_type['num_vehicles_detected']}")
        
        print(f"\n🛣️ 车道分析")
        print("-" * 30)
        for lane_name, stats in lane_analysis['lane_stats'].items():
            lane_chinese = {'right': '右车道', 'middle': '中车道', 'left': '左车道'}[lane_name]
            print(f"{lane_chinese}: 平均风险 {stats['mean_risk']:.0f}N, "
                  f"最大风险 {stats['max_risk']:.0f}N")
        
        safest_chinese = {'right': '右车道', 'middle': '中车道', 'left': '左车道'}[lane_analysis['safest_lane']]
        print(f"推荐车道: {safest_chinese}")
        
        print(f"\n🛡️ 安全评估")
        print("-" * 30)
        safety_chinese = {
            'safe': '安全',
            'low_risk': '低风险',
            'caution': '需谨慎',
            'dangerous': '危险',
            'critical': '极危险'
        }[safety_assessment['safety_level']]
        print(f"安全等级: {safety_chinese}")
        print(f"安全得分: {safety_assessment['safety_score']}/100")
        
        print(f"\n💡 驾驶建议")
        print("-" * 30)
        for advice in decision_advice:
            print(f"  {advice}")
        
        print("\n" + "=" * 50)
        print("✅ 分析完成！")

    def create_enhanced_visualization(self, F_total: np.ndarray, x_range: Tuple[float, float],
                                    y_range: Tuple[float, float], peaks_info: List[Dict]):
        """创建增强版可视化"""
        fig = plt.figure(figsize=(15, 10))
        
        # 3D图
        ax1 = fig.add_subplot(221, projection='3d')
        
        X = np.linspace(x_range[0], x_range[1], F_total.shape[1])
        Y = np.linspace(y_range[0], y_range[1], F_total.shape[0])
        X, Y = np.meshgrid(X, Y)
        
        surf = ax1.plot_surface(X, Y, F_total, cmap='viridis', alpha=0.8)
        
        # 标记峰值
        for i, peak in enumerate(peaks_info[:5]):
            ax1.scatter([peak['x_pos']], [peak['y_pos']], [peak['risk_value']], 
                       c='red', s=100, alpha=0.8)
            ax1.text(peak['x_pos'], peak['y_pos'], peak['risk_value'] + 1000,
                    f'P{i+1}', fontsize=8)
        
        ax1.set_title('3D风险场可视化')
        ax1.set_xlabel('X [m]')
        ax1.set_ylabel('Y [m]') 
        ax1.set_zlabel('风险 [N]')
        
        # 俯视图
        ax2 = fig.add_subplot(222)
        im = ax2.imshow(F_total, extent=[x_range[0], x_range[1], y_range[0], y_range[1]],
                       origin='lower', cmap='viridis', aspect='auto')
        
        # 标记峰值
        for i, peak in enumerate(peaks_info[:5]):
            ax2.scatter(peak['x_pos'], peak['y_pos'], c='red', s=100, 
                       marker='x', linewidths=2)
            ax2.text(peak['x_pos'] + 2, peak['y_pos'] + 0.2, f'P{i+1}', 
                    color='red', fontweight='bold')
        
        ax2.set_title('俯视图 - 风险分布')
        ax2.set_xlabel('X [m]')
        ax2.set_ylabel('Y [m]')
        plt.colorbar(im, ax=ax2, label='风险 [N]')
        
        # 横向风险分布
        ax3 = fig.add_subplot(223)
        y_profile = np.mean(F_total, axis=1)
        ax3.plot(Y[:, 0], y_profile, 'b-', linewidth=2)
        ax3.fill_between(Y[:, 0], y_profile, alpha=0.3)
        ax3.set_title('横向风险分布（车道方向）')
        ax3.set_xlabel('Y [m] (车道位置)')
        ax3.set_ylabel('平均风险 [N]')
        ax3.grid(True, alpha=0.3)
        
        # 纵向风险分布
        ax4 = fig.add_subplot(224)
        x_profile = np.mean(F_total, axis=0)
        ax4.plot(X[0, :], x_profile, 'g-', linewidth=2)
        ax4.fill_between(X[0, :], x_profile, alpha=0.3)
        ax4.set_title('纵向风险分布（行驶方向）')
        ax4.set_xlabel('X [m] (行驶方向)')
        ax4.set_ylabel('平均风险 [N]')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

def main():
    """主函数 - 演示如何使用分析器"""
    print("🚗 风险场可视化分析工具")
    print("=" * 50)
    
    # 创建分析器
    analyzer = RiskFieldAnalyzer()
    
    # 加载示例数据
    try:
        from risk_field_model import RiskFieldModel
        
        # 创建示例场景
        model = RiskFieldModel(performance_mode='fast')
        
        # 示例车辆数据 (格式: [id, x, y, speed, ...])
        vehicles = [
            [1, 20, 2.5, 25],    # id, x, y, speed
            [2, 45, 6.5, 30], 
            [3, 70, 2.0, 28],
        ]
        
        # 计算风险场
        F_total, _, _, _ = model.calculate_scene_risk_field(vehicles)
        
        # 执行分析
        analysis_results = analyzer.analyze_risk_field(F_total, (0, 100), (0, 8))
        
        # 创建增强可视化
        fig = analyzer.create_enhanced_visualization(
            F_total, (0, 100), (0, 8), analysis_results['peaks_info']
        )
        plt.show()
        
        print(f"\n📈 分析报告已生成！")
        print(f"🎯 安全得分: {analysis_results['safety_assessment']['safety_score']}/100")
        
    except ImportError as e:
        print(f"❌ 无法导入风险场模型: {e}")
        print("请确保 risk_field_model.py 在当前目录中")

if __name__ == "__main__":
    main()

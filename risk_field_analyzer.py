#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Risk Field Visualization Analyzer
é£é™©åœºå¯è§†åŒ–åˆ†æå·¥å…·

This module provides interactive tools for analyzing and interpreting
risk field visualizations generated by the risk field model.

Author: Risk Field Model Team
Date: 2024
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
from typing import Dict, List, Tuple, Optional
import warnings

class RiskFieldAnalyzer:
    """
    é£é™©åœºåˆ†æå™¨
    
    æä¾›é£é™©åœºå¯è§†åŒ–çš„è‡ªåŠ¨åˆ†æå’Œè§£è¯»åŠŸèƒ½
    """
    
    def __init__(self):
        """åˆå§‹åŒ–åˆ†æå™¨"""
        self.risk_levels = {
            'safe': (0, 1000),
            'low': (1000, 5000),
            'medium': (5000, 20000),
            'high': (20000, 100000),
            'extreme': (100000, float('inf'))
        }
        
        self.risk_colors = {
            'safe': '#000080',      # æ·±è“
            'low': '#0066CC',       # è“è‰²
            'medium': '#6600CC',    # ç´«è‰²
            'high': '#CC6600',      # æ©™è‰²
            'extreme': '#CC0000'    # çº¢è‰²
        }
        
        # åœºæ™¯ç±»å‹æ¨¡å¼
        self.scenario_patterns = {
            'highway_straight': 'é«˜é€Ÿç›´è¡Œ',
            'overtaking': 'è¶…è½¦åœºæ™¯',
            'lane_change': 'å˜é“åœºæ™¯', 
            'merging': 'æ±‡å…¥åœºæ™¯',
            'emergency_brake': 'ç´§æ€¥åˆ¶åŠ¨',
            'multi_vehicle': 'å¤šè½¦äº¤äº’'
        }
    
    def analyze_risk_field(self, F_total: np.ndarray, x_range: Tuple[float, float], 
                          y_range: Tuple[float, float]) -> Dict:
        """
        å…¨é¢åˆ†æé£é™©åœº
        
        Args:
            F_total: é£é™©åœºçŸ©é˜µ
            x_range: Xè½´èŒƒå›´ (min, max)
            y_range: Yè½´èŒƒå›´ (min, max)
            
        Returns:
            Dict: åˆ†æç»“æœ
        """
        print("ğŸ” å¼€å§‹é£é™©åœºåˆ†æ...")
        print("=" * 50)
        
        # åŸºç¡€ç»Ÿè®¡
        basic_stats = self._calculate_basic_stats(F_total)
        
        # é£é™©åˆ†å¸ƒåˆ†æ
        risk_distribution = self._analyze_risk_distribution(F_total)
        
        # å³°å€¼æ£€æµ‹
        peaks_info = self._detect_peaks(F_total, x_range, y_range)
        
        # åœºæ™¯è¯†åˆ«
        scenario_type = self._identify_scenario(F_total, peaks_info)
        
        # è½¦é“åˆ†æ
        lane_analysis = self._analyze_lanes(F_total, y_range)
        
        # å®‰å…¨è¯„ä¼°
        safety_assessment = self._assess_safety(basic_stats, risk_distribution)
        
        # å†³ç­–å»ºè®®
        decision_advice = self._generate_advice(basic_stats, scenario_type, safety_assessment)
        
        # æ‰“å°åˆ†æç»“æœ
        self._print_analysis_results(basic_stats, risk_distribution, peaks_info, 
                                   scenario_type, lane_analysis, safety_assessment, 
                                   decision_advice)
        
        return {
            'basic_stats': basic_stats,
            'risk_distribution': risk_distribution,
            'peaks_info': peaks_info,
            'scenario_type': scenario_type,
            'lane_analysis': lane_analysis,
            'safety_assessment': safety_assessment,
            'decision_advice': decision_advice
        }
    
    def _calculate_basic_stats(self, F_total: np.ndarray) -> Dict:
        """è®¡ç®—åŸºç¡€ç»Ÿè®¡ä¿¡æ¯"""
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            
            return {
                'max_risk': float(np.max(F_total)),
                'min_risk': float(np.min(F_total)),
                'mean_risk': float(np.mean(F_total)),
                'std_risk': float(np.std(F_total)),
                'total_points': F_total.size,
                'shape': F_total.shape
            }
    
    def _analyze_risk_distribution(self, F_total: np.ndarray) -> Dict:
        """åˆ†æé£é™©åˆ†å¸ƒ"""
        distribution = {}
        total_points = F_total.size
        
        for level, (min_val, max_val) in self.risk_levels.items():
            if max_val == float('inf'):
                count = np.sum(F_total >= min_val)
            else:
                count = np.sum((F_total >= min_val) & (F_total < max_val))
            
            distribution[level] = {
                'count': int(count),
                'percentage': float(count / total_points * 100)
            }
        
        return distribution
    
    def _detect_peaks(self, F_total: np.ndarray, x_range: Tuple[float, float], 
                     y_range: Tuple[float, float]) -> List[Dict]:
        """æ£€æµ‹é£é™©å³°å€¼"""
        from scipy.signal import find_peaks
        
        peaks_info = []
        
        # é˜ˆå€¼è®¾å®šï¼ˆå–æœ€å¤§å€¼çš„20%ä½œä¸ºå³°å€¼æ£€æµ‹é˜ˆå€¼ï¼‰
        threshold = np.max(F_total) * 0.2
        
        # åœ¨æ¯ä¸€è¡Œä¸­å¯»æ‰¾å³°å€¼
        dy = (y_range[1] - y_range[0]) / F_total.shape[0]
        dx = (x_range[1] - x_range[0]) / F_total.shape[1]
        
        for i, row in enumerate(F_total):
            if np.max(row) > threshold:
                peaks, properties = find_peaks(row, height=threshold, distance=5)
                
                for j, peak_idx in enumerate(peaks):
                    peak_info = {
                        'x_pos': x_range[0] + peak_idx * dx,
                        'y_pos': y_range[0] + i * dy,
                        'risk_value': float(F_total[i, peak_idx]),
                        'x_index': peak_idx,
                        'y_index': i
                    }
                    peaks_info.append(peak_info)
        
        # æŒ‰é£é™©å€¼æ’åº
        peaks_info.sort(key=lambda x: x['risk_value'], reverse=True)
        
        return peaks_info[:10]  # è¿”å›å‰10ä¸ªæœ€é«˜å³°å€¼
    
    def _identify_scenario(self, F_total: np.ndarray, peaks_info: List[Dict]) -> Dict:
        """è¯†åˆ«é©¾é©¶åœºæ™¯ç±»å‹"""
        if len(peaks_info) == 0:
            return {'type': 'safe_driving', 'confidence': 1.0, 'description': 'å®‰å…¨é©¾é©¶'}
        
        max_risk = np.max(F_total)
        num_peaks = len(peaks_info)
        
        # åœºæ™¯åˆ¤æ–­é€»è¾‘
        if max_risk > 50000:
            scenario_type = 'emergency_brake'
            description = 'ç´§æ€¥åˆ¶åŠ¨åœºæ™¯'
            confidence = 0.9
        elif num_peaks >= 4:
            scenario_type = 'multi_vehicle' 
            description = 'å¤šè½¦äº¤äº’åœºæ™¯'
            confidence = 0.8
        elif num_peaks >= 2:
            # æ£€æŸ¥æ˜¯å¦ä¸ºå¹¶æ’ï¼ˆè¶…è½¦/å˜é“ï¼‰
            y_positions = [peak['y_pos'] for peak in peaks_info[:3]]
            if len(set(np.round(np.array(y_positions), 1))) >= 2:
                scenario_type = 'overtaking'
                description = 'è¶…è½¦/å˜é“åœºæ™¯'
                confidence = 0.7
            else:
                scenario_type = 'highway_straight'
                description = 'é«˜é€Ÿç›´è¡Œåœºæ™¯'
                confidence = 0.8
        else:
            scenario_type = 'highway_straight'
            description = 'å•è½¦æˆ–ç®€å•åœºæ™¯'
            confidence = 0.6
        
        return {
            'type': scenario_type,
            'confidence': confidence,
            'description': description,
            'num_vehicles_detected': num_peaks
        }
    
    def _analyze_lanes(self, F_total: np.ndarray, y_range: Tuple[float, float]) -> Dict:
        """åˆ†æè½¦é“é£é™©åˆ†å¸ƒ"""
        height = F_total.shape[0]
        
        # å‡è®¾æ ‡å‡†3è½¦é“é«˜é€Ÿå…¬è·¯ï¼š0-4m (å³), 4-8m (ä¸­), 8-12m (å·¦)
        if y_range[1] <= 8:  # åŒè½¦é“
            right_lane_idx = slice(0, height//2)
            left_lane_idx = slice(height//2, height)
            lanes = ['right', 'left']
        else:  # ä¸‰è½¦é“æˆ–æ›´å¤š
            right_lane_idx = slice(0, height//3)
            middle_lane_idx = slice(height//3, 2*height//3)
            left_lane_idx = slice(2*height//3, height)
            lanes = ['right', 'middle', 'left']
        
        lane_stats = {}
        
        if y_range[1] <= 8:
            lane_stats['right'] = {
                'mean_risk': float(np.mean(F_total[right_lane_idx, :])),
                'max_risk': float(np.max(F_total[right_lane_idx, :]))
            }
            lane_stats['left'] = {
                'mean_risk': float(np.mean(F_total[left_lane_idx, :])),
                'max_risk': float(np.max(F_total[left_lane_idx, :]))
            }
        else:
            lane_stats['right'] = {
                'mean_risk': float(np.mean(F_total[right_lane_idx, :])),
                'max_risk': float(np.max(F_total[right_lane_idx, :]))
            }
            lane_stats['middle'] = {
                'mean_risk': float(np.mean(F_total[middle_lane_idx, :])),
                'max_risk': float(np.max(F_total[middle_lane_idx, :]))
            }
            lane_stats['left'] = {
                'mean_risk': float(np.mean(F_total[left_lane_idx, :])),
                'max_risk': float(np.max(F_total[left_lane_idx, :]))
            }
        
        # æ¨èè½¦é“
        safest_lane = min(lane_stats.keys(), key=lambda x: lane_stats[x]['mean_risk'])
        
        return {
            'lane_stats': lane_stats,
            'safest_lane': safest_lane,
            'lanes_detected': lanes
        }
    
    def _assess_safety(self, basic_stats: Dict, risk_distribution: Dict) -> Dict:
        """å®‰å…¨è¯„ä¼°"""
        max_risk = basic_stats['max_risk']
        mean_risk = basic_stats['mean_risk']
        
        # å®‰å…¨ç­‰çº§è¯„ä¼°
        if max_risk > 100000:
            safety_level = 'critical'
            safety_score = 0
        elif max_risk > 20000:
            safety_level = 'dangerous'
            safety_score = 20
        elif max_risk > 5000:
            safety_level = 'caution'
            safety_score = 60
        elif mean_risk > 1000:
            safety_level = 'low_risk'
            safety_score = 80
        else:
            safety_level = 'safe'
            safety_score = 95
        
        # åŸºäºåˆ†å¸ƒçš„è°ƒæ•´
        if risk_distribution['high']['percentage'] > 10:
            safety_score = max(0, safety_score - 30)
        elif risk_distribution['medium']['percentage'] > 20:
            safety_score = max(0, safety_score - 15)
        
        return {
            'safety_level': safety_level,
            'safety_score': safety_score,
            'max_risk_level': self._get_risk_level(max_risk),
            'mean_risk_level': self._get_risk_level(mean_risk)
        }
    
    def _get_risk_level(self, risk_value: float) -> str:
        """è·å–é£é™©ç­‰çº§"""
        for level, (min_val, max_val) in self.risk_levels.items():
            if min_val <= risk_value < max_val:
                return level
        return 'extreme'
    
    def _generate_advice(self, basic_stats: Dict, scenario_type: Dict, 
                        safety_assessment: Dict) -> List[str]:
        """ç”Ÿæˆé©¾é©¶å»ºè®®"""
        advice = []
        
        safety_level = safety_assessment['safety_level']
        max_risk = basic_stats['max_risk']
        scenario = scenario_type['type']
        
        # åŸºäºå®‰å…¨ç­‰çº§çš„å»ºè®®
        if safety_level == 'critical':
            advice.extend([
                "ğŸš¨ ç«‹å³é‡‡å–ç´§æ€¥æªæ–½ï¼",
                "âš¡ ç´§æ€¥åˆ¶åŠ¨æˆ–ç´§æ€¥é¿è®©",
                "ğŸ“ è€ƒè™‘å¯åŠ¨ç´§æ€¥å‘¼å«ç³»ç»Ÿ"
            ])
        elif safety_level == 'dangerous':
            advice.extend([
                "âš ï¸ é«˜é£é™©çŠ¶æ€ï¼ç«‹å³å‡é€Ÿ",
                "ğŸ”„ å‡†å¤‡å˜é“åˆ°å®‰å…¨è½¦é“",
                "ğŸ‘ï¸ æé«˜è­¦æƒ•ï¼Œå‡†å¤‡åº”æ€¥ååº”"
            ])
        elif safety_level == 'caution':
            advice.extend([
                "ğŸ”¶ ä¿æŒè°¨æ…é©¾é©¶",
                "ğŸ“‰ é€‚å½“é™ä½è½¦é€Ÿ",
                "ğŸ“ å¢å¤§ä¸å‰è½¦è·ç¦»"
            ])
        
        # åŸºäºåœºæ™¯çš„å»ºè®®
        if scenario == 'overtaking':
            advice.append("ğŸš— è¶…è½¦åœºæ™¯ï¼šç¡®è®¤å®‰å…¨è·ç¦»åå®Œæˆè¶…è½¦")
        elif scenario == 'multi_vehicle':
            advice.append("ğŸš™ å¤šè½¦ç¯å¢ƒï¼šä¿æŒå®‰å…¨è½¦è·ï¼Œé¿å…æ€¥åŠ¨ä½œ")
        elif scenario == 'emergency_brake':
            advice.append("ğŸ›‘ ç´§æ€¥åˆ¶åŠ¨ï¼šæ£€æŸ¥åæ–¹è½¦è¾†ï¼Œå¼€å¯å±é™©è­¦å‘Šç¯")
        
        # é€šç”¨å»ºè®®
        if max_risk > 10000:
            advice.append("ğŸ¯ å»ºè®®æ¿€æ´»é«˜çº§é©¾é©¶è¾…åŠ©ç³»ç»Ÿ(ADAS)")
        
        return advice if advice else ["âœ… å½“å‰ç¯å¢ƒç›¸å¯¹å®‰å…¨ï¼Œä¿æŒæ­£å¸¸é©¾é©¶"]
    
    def _print_analysis_results(self, basic_stats: Dict, risk_distribution: Dict,
                              peaks_info: List[Dict], scenario_type: Dict,
                              lane_analysis: Dict, safety_assessment: Dict,
                              decision_advice: List[str]):
        """æ‰“å°åˆ†æç»“æœ"""
        print("\nğŸ“Š åŸºç¡€ç»Ÿè®¡ä¿¡æ¯")
        print("-" * 30)
        print(f"æœ€å¤§é£é™©å€¼: {basic_stats['max_risk']:.2f} N")
        print(f"å¹³å‡é£é™©å€¼: {basic_stats['mean_risk']:.2f} N")
        print(f"é£é™©æ ‡å‡†å·®: {basic_stats['std_risk']:.2f} N")
        print(f"åˆ†æç½‘æ ¼: {basic_stats['shape'][0]} Ã— {basic_stats['shape'][1]}")
        
        print("\nğŸ¯ é£é™©åˆ†å¸ƒ")
        print("-" * 30)
        for level, data in risk_distribution.items():
            level_name = {
                'safe': 'å®‰å…¨',
                'low': 'ä½é£é™©', 
                'medium': 'ä¸­ç­‰é£é™©',
                'high': 'é«˜é£é™©',
                'extreme': 'æé«˜é£é™©'
            }[level]
            print(f"{level_name}: {data['percentage']:.1f}% ({data['count']} ç‚¹)")
        
        print(f"\nğŸ”ï¸ æ£€æµ‹åˆ° {len(peaks_info)} ä¸ªé£é™©å³°å€¼")
        print("-" * 30)
        for i, peak in enumerate(peaks_info[:5]):  # æ˜¾ç¤ºå‰5ä¸ª
            print(f"å³°å€¼ {i+1}: X={peak['x_pos']:.1f}m, Y={peak['y_pos']:.1f}m, "
                  f"é£é™©={peak['risk_value']:.0f}N")
        
        print(f"\nğŸ¬ åœºæ™¯è¯†åˆ«")
        print("-" * 30)
        print(f"åœºæ™¯ç±»å‹: {scenario_type['description']}")
        print(f"ç½®ä¿¡åº¦: {scenario_type['confidence']:.1%}")
        print(f"æ£€æµ‹è½¦è¾†æ•°: {scenario_type['num_vehicles_detected']}")
        
        print(f"\nğŸ›£ï¸ è½¦é“åˆ†æ")
        print("-" * 30)
        for lane_name, stats in lane_analysis['lane_stats'].items():
            lane_chinese = {'right': 'å³è½¦é“', 'middle': 'ä¸­è½¦é“', 'left': 'å·¦è½¦é“'}[lane_name]
            print(f"{lane_chinese}: å¹³å‡é£é™© {stats['mean_risk']:.0f}N, "
                  f"æœ€å¤§é£é™© {stats['max_risk']:.0f}N")
        
        safest_chinese = {'right': 'å³è½¦é“', 'middle': 'ä¸­è½¦é“', 'left': 'å·¦è½¦é“'}[lane_analysis['safest_lane']]
        print(f"æ¨èè½¦é“: {safest_chinese}")
        
        print(f"\nğŸ›¡ï¸ å®‰å…¨è¯„ä¼°")
        print("-" * 30)
        safety_chinese = {
            'safe': 'å®‰å…¨',
            'low_risk': 'ä½é£é™©',
            'caution': 'éœ€è°¨æ…',
            'dangerous': 'å±é™©',
            'critical': 'æå±é™©'
        }[safety_assessment['safety_level']]
        print(f"å®‰å…¨ç­‰çº§: {safety_chinese}")
        print(f"å®‰å…¨å¾—åˆ†: {safety_assessment['safety_score']}/100")
        
        print(f"\nğŸ’¡ é©¾é©¶å»ºè®®")
        print("-" * 30)
        for advice in decision_advice:
            print(f"  {advice}")
        
        print("\n" + "=" * 50)
        print("âœ… åˆ†æå®Œæˆï¼")

    def create_enhanced_visualization(self, F_total: np.ndarray, x_range: Tuple[float, float],
                                    y_range: Tuple[float, float], peaks_info: List[Dict]):
        """åˆ›å»ºå¢å¼ºç‰ˆå¯è§†åŒ–"""
        fig = plt.figure(figsize=(15, 10))
        
        # 3Då›¾
        ax1 = fig.add_subplot(221, projection='3d')
        
        X = np.linspace(x_range[0], x_range[1], F_total.shape[1])
        Y = np.linspace(y_range[0], y_range[1], F_total.shape[0])
        X, Y = np.meshgrid(X, Y)
        
        surf = ax1.plot_surface(X, Y, F_total, cmap='viridis', alpha=0.8)
        
        # æ ‡è®°å³°å€¼
        for i, peak in enumerate(peaks_info[:5]):
            ax1.scatter([peak['x_pos']], [peak['y_pos']], [peak['risk_value']], 
                       c='red', s=100, alpha=0.8)
            ax1.text(peak['x_pos'], peak['y_pos'], peak['risk_value'] + 1000,
                    f'P{i+1}', fontsize=8)
        
        ax1.set_title('3Dé£é™©åœºå¯è§†åŒ–')
        ax1.set_xlabel('X [m]')
        ax1.set_ylabel('Y [m]') 
        ax1.set_zlabel('é£é™© [N]')
        
        # ä¿¯è§†å›¾
        ax2 = fig.add_subplot(222)
        im = ax2.imshow(F_total, extent=[x_range[0], x_range[1], y_range[0], y_range[1]],
                       origin='lower', cmap='viridis', aspect='auto')
        
        # æ ‡è®°å³°å€¼
        for i, peak in enumerate(peaks_info[:5]):
            ax2.scatter(peak['x_pos'], peak['y_pos'], c='red', s=100, 
                       marker='x', linewidths=2)
            ax2.text(peak['x_pos'] + 2, peak['y_pos'] + 0.2, f'P{i+1}', 
                    color='red', fontweight='bold')
        
        ax2.set_title('ä¿¯è§†å›¾ - é£é™©åˆ†å¸ƒ')
        ax2.set_xlabel('X [m]')
        ax2.set_ylabel('Y [m]')
        plt.colorbar(im, ax=ax2, label='é£é™© [N]')
        
        # æ¨ªå‘é£é™©åˆ†å¸ƒ
        ax3 = fig.add_subplot(223)
        y_profile = np.mean(F_total, axis=1)
        ax3.plot(Y[:, 0], y_profile, 'b-', linewidth=2)
        ax3.fill_between(Y[:, 0], y_profile, alpha=0.3)
        ax3.set_title('æ¨ªå‘é£é™©åˆ†å¸ƒï¼ˆè½¦é“æ–¹å‘ï¼‰')
        ax3.set_xlabel('Y [m] (è½¦é“ä½ç½®)')
        ax3.set_ylabel('å¹³å‡é£é™© [N]')
        ax3.grid(True, alpha=0.3)
        
        # çºµå‘é£é™©åˆ†å¸ƒ
        ax4 = fig.add_subplot(224)
        x_profile = np.mean(F_total, axis=0)
        ax4.plot(X[0, :], x_profile, 'g-', linewidth=2)
        ax4.fill_between(X[0, :], x_profile, alpha=0.3)
        ax4.set_title('çºµå‘é£é™©åˆ†å¸ƒï¼ˆè¡Œé©¶æ–¹å‘ï¼‰')
        ax4.set_xlabel('X [m] (è¡Œé©¶æ–¹å‘)')
        ax4.set_ylabel('å¹³å‡é£é™© [N]')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨åˆ†æå™¨"""
    print("ğŸš— é£é™©åœºå¯è§†åŒ–åˆ†æå·¥å…·")
    print("=" * 50)
    
    # åˆ›å»ºåˆ†æå™¨
    analyzer = RiskFieldAnalyzer()
    
    # åŠ è½½ç¤ºä¾‹æ•°æ®
    try:
        from risk_field_model import RiskFieldModel
        
        # åˆ›å»ºç¤ºä¾‹åœºæ™¯
        model = RiskFieldModel(performance_mode='fast')
        
        # ç¤ºä¾‹è½¦è¾†æ•°æ® (æ ¼å¼: [id, x, y, speed, ...])
        vehicles = [
            [1, 20, 2.5, 25],    # id, x, y, speed
            [2, 45, 6.5, 30], 
            [3, 70, 2.0, 28],
        ]
        
        # è®¡ç®—é£é™©åœº
        F_total, _, _, _ = model.calculate_scene_risk_field(vehicles)
        
        # æ‰§è¡Œåˆ†æ
        analysis_results = analyzer.analyze_risk_field(F_total, (0, 100), (0, 8))
        
        # åˆ›å»ºå¢å¼ºå¯è§†åŒ–
        fig = analyzer.create_enhanced_visualization(
            F_total, (0, 100), (0, 8), analysis_results['peaks_info']
        )
        plt.show()
        
        print(f"\nğŸ“ˆ åˆ†ææŠ¥å‘Šå·²ç”Ÿæˆï¼")
        print(f"ğŸ¯ å®‰å…¨å¾—åˆ†: {analysis_results['safety_assessment']['safety_score']}/100")
        
    except ImportError as e:
        print(f"âŒ æ— æ³•å¯¼å…¥é£é™©åœºæ¨¡å‹: {e}")
        print("è¯·ç¡®ä¿ risk_field_model.py åœ¨å½“å‰ç›®å½•ä¸­")

if __name__ == "__main__":
    main()
